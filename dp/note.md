"""
# 贪心法：只顾眼前利益
# DP： 全局最优
# 贪心比较了选择，dp比较了做出选择后的结果
"""
"""
三种适用DP的场景
# 求最值（max/min）
# 求方案总数（sum）
# 求可行性（or）
"""
"""
三种不适用DP的场景
# 求所有的具体方案
# 输入数据是无序的
# 暴力算法时间复杂度已经是多项式级别
# 有循环依赖
"""
"""
# 将函数的计算结果保存下来，下次通过同样的参数访问时，直接返回保存下来的结果
# 问：
# 1. 对这个函数有什么限制条件没有？ 必须是纯函数， input不变output不变
# 2. 和系统设计中的什么很像？ cache
"""
"""
# 记忆化搜索通常能够将指数级别的时间复杂度降低到多项式级别。
# 记忆化搜索的本质：动态规划
# 动态规划为什么会快？
# 动态规划与分治的区别？
# 重复计算！
"""
"""
# 记忆化搜索 = 动态规划(DP)
# 记忆化搜索是动态规划的一种实现方式
# 记忆化搜索是用搜索的方式实现了动态规划
# 因此记忆化搜索，就是动态规划
"""
"""
# 记忆化搜索的缺陷
# 递归深度太深，导致 StackOverflow
"""
"""
递归四要素 vs 动规四要素
动规的状态 State —— 递归的定义
- 用 f[i] 或者 f[i][j] 代表在某些特定条件下某个规模更小的问题的答案
- 规模更小用参数 i,j 之类的来划定
动规的方程 Function —— 递归的拆解
- 大问题如何拆解为小问题
- f[i][j] = 通过规模更小的一些状态求 max / min / sum / or 来进行推导
动规的初始化 Initialize —— 递归的出口
- 设定无法再拆解的极限小的状态下的值
- 如 f[i][0] 或者 f[0][i]
动规的答案 Answer —— 递归的调用
- 最后要求的答案是什么
- 如 f[n][m] 或者 max(f[n][0], f[n][1] … f[n][m])
"""


四个组成部分
• 确定状态
• 研究最优策略的最后一步
• 化为子问题

• 转移方程
• 根据子问题定义直接得到

• 初始条件和边界情况
• 细心，考虑周全

• 计算顺序
• 利用之前的计算结果

memo: dvcq 从当前 定义的起点 开始 到 隐藏终点的结果， 计算路径 从大到小， 结果路径从小到大, 结果在头上
dp
